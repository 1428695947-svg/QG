# 数码管与矩阵按键
## 数码管
- 段选与位选
  - 段选是对 **a~g、dp 各个段的控制**，控制“这一位数码管要亮哪些段”
  - 位选能决定“哪一位数字亮”

数码管编码表
共阴：1 = 亮
| 编码 | 数字 |
| --- |---|
| 0x3F | 0 |
| 0x06 | 1 |
| 0x5B | 2 |
| 0x4F | 3 |
| 0x66 | 4 |
| 0x6D | 5 |
| 0x7D | 6 |
| 0x07 | 7 |
| 0x7F | 8 |
| 0x6F | 9 |

共阳：0 = 亮
|编码|数字|
|--- |---|
|0xC0| 0 |
|0xF9| 1 |
|0xA4| 2 |
|0xB0| 3 |
|0x99| 4 |
|0x92| 5 |
|0x82| 6 |
|0xF8| 7 |
|0x80| 8 |
|0x90| 9 |

**共阳编码 = 共阴编码按位取反**

代码格式如下：
```C
// 共阴
// 位序：dp g f e d c b a
unsigned char NixieTable[10] = {
    0x3F, // 0
    0x06, // 1
    0x5B, // 2
    0x4F, // 3
    0x66, // 4
    0x6D, // 5
    0x7D, // 6
    0x07, // 7
    0x7F, // 8
    0x6F  // 9
};

// 共阳
// 位序：dp g f e d c b a
unsigned char NixieTable[10] = {
    0xC0, // 0
    0xF9, // 1
    0xA4, // 2
    0xB0, // 3
    0x99, // 4
    0x92, // 5
    0x82, // 6
    0xF8, // 7
    0x80, // 8
    0x90  // 9
};
```

段选+位选

```C
//数码管段码表
unsigned char NixieTable[]={0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F};

//数码管显示子函数
void Nixie(unsigned char Location,Number)
{
	switch(Location)		//位码输出
	{
		case 1:P2_4=1;P2_3=1;P2_2=1;break;
		case 2:P2_4=1;P2_3=1;P2_2=0;break;
		case 3:P2_4=1;P2_3=0;P2_2=1;break;
		case 4:P2_4=1;P2_3=0;P2_2=0;break;
		case 5:P2_4=0;P2_3=1;P2_2=1;break;
		case 6:P2_4=0;P2_3=1;P2_2=0;break;
		case 7:P2_4=0;P2_3=0;P2_2=1;break;
		case 8:P2_4=0;P2_3=0;P2_2=0;break;
	}
	P0=NixieTable[Number];	//段码输出
}
```

### 数码管显示闪烁之优化大法！！
- 闪烁原因：数码管本质是一个LED，稳定发光需要持续电流，并没有保持显示的能力。若程序在编写时选择只点亮一次，然后延时1000ms，会导致输入给到LED的电流并不稳定，在哪之后人眼看见的数码管的光来自**直流+人眼抖动+电源纹波**
- 解决方式：
    1. 减少单次延时的时间，提高刷新频率，例如延时5ms后就再次点亮一次，反复200次
    2. 使用定时器，每隔1ms或者5ms就扫描一次，刷新数码管

## 矩阵按键
 可采用逐行或者逐列扫描的方式，检测按键是否按下
 **消抖方法**
 - **计数型消抖**：只有连续N次扫描结果一致，才认为状态改变（需要打开定时器，可以使用定时器定时扫描来完成，想要代码更优雅可以加一个状态机）
   ```
   if(当前状态 == 上次状态)
    cnt++
    else
        cnt = 0

    if(cnt >= THRESHOLD)
        状态确认
    ```
- **状态机消抖**：适合长按、连击或者需要组合键